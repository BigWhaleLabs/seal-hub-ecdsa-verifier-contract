/*
  Test cases are courtesy of @bankisan
*/

import * as elliptic from 'elliptic'
import * as snarkjs from 'snarkjs'
import { computeAddress } from 'ethers/lib/utils'
import { cwd } from 'process'
import { ethers } from 'hardhat'
import { expect } from 'chai'
import { getMessage } from '@big-whale-labs/seal-hub-kit'
import { hashPersonalMessage } from '@ethereumjs/util'
import { readFileSync } from 'fs'
import { resolve } from 'path'
import { version } from '../package.json'
import { wasm as wasmTester } from 'circom_tester'
import BN from 'bn.js'
import expectAssertFailure from '../utils/expectAssertFailure'
// import Mimc7 from '../utils/Mimc7'

const secp256k1 = new elliptic.ec('secp256k1')

const REGISTERS = 4n
const STRIDE = 8n
const NUM_STRIDES = 256n / STRIDE // = 32

interface ExtendedBasePoint extends elliptic.curve.base.BasePoint {
  x: BN
  y: BN
}

function getPointPrecomputes(point: ExtendedBasePoint) {
  const keyPoint = secp256k1.keyFromPublic({
    x: Buffer.from(point.x.toString(16).padStart(64, '0'), 'hex').toString(
      'hex'
    ),
    y: Buffer.from(point.y.toString(16).padStart(64, '0'), 'hex').toString(
      'hex'
    ),
  })
  const gPowers = [] as string[][][][]
  for (let i = 0n; i < NUM_STRIDES; i++) {
    const stride: string[][][] = []
    const power = 2n ** (i * STRIDE)
    for (let j = 0n; j < 2n ** STRIDE; j++) {
      const l = j * power

      const gPower = keyPoint
        .getPublic()
        .mul(new BN(l.toString())) as ExtendedBasePoint
      const x = splitToRegisters(gPower.x)
      const y = splitToRegisters(gPower.y)
      stride.push([x, y])
    }
    gPowers.push(stride)
  }
  return gPowers
}

function addHexPrefix(str: string) {
  return `0x${str}`
}

function splitToRegisters(value?: BN | string) {
  const registers = [] as bigint[]

  if (!value) {
    return ['0', '0', '0', '0']
  }
  const hex = value.toString('hex').padStart(64, '0')
  for (let k = 0; k < REGISTERS; k++) {
    // 64bit = 16 chars in hex
    const val = hex.slice(k * 16, (k + 1) * 16)

    registers.unshift(BigInt(addHexPrefix(val)))
  }

  return registers.map((el) => el.toString())
}

async function getSolidityCallProof(proofName: string) {
  const proof = JSON.parse(
    readFileSync(
      resolve(cwd(), 'exploit-proofs', `proof-${proofName}.json`),
      'utf8'
    )
  )
  const publicInputs = JSON.parse(
    readFileSync(
      resolve(cwd(), 'exploit-proofs', `public-${proofName}.json`),
      'utf8'
    )
  )
  const callDataString = await snarkjs.groth16.exportSolidityCallData(
    proof,
    publicInputs
  )
  const splitData = callDataString.split('],[')
  return {
    a: JSON.parse(`${splitData[0]}]`),
    b: JSON.parse(`[${splitData[1]}],[${splitData[2]}]`),
    c: JSON.parse(`[${splitData[3]}]`),
    input: JSON.parse(`[${splitData[4]}`),
  }
}

describe('Cannot prove a signature of a public key without private key', function () {
  before(async function () {
    // Set up circuits.
    this.circuit = await wasmTester('circuits/ECDSAChecker.circom')
    this.uCircuit = await wasmTester('circuits/UPrecomputesChecker.circom')

    // Get UPrecomputesCheckerVerifier contract
    const uPrecomputesFactory = await ethers.getContractFactory(
      'UPrecomputesCheckerVerifier'
    )
    this.uPrecomputesContract = await uPrecomputesFactory.deploy(version)
    await this.uPrecomputesContract.deployed()
    // Get ECDSACheckerVerifier contract
    const ecdsaFactory = await ethers.getContractFactory('ECDSACheckerVerifier')
    this.ecdsaContract = await ecdsaFactory.deploy(version)
    await this.ecdsaContract.deployed()
    // Get CompleteECDSACheckerVerifier contract
    const factory = await ethers.getContractFactory(
      'CompleteECDSACheckerVerifier'
    )
    const contract = await factory.deploy(
      version,
      this.ecdsaContract.address,
      this.uPrecomputesContract.address
    )
    this.contract = contract
    await this.contract.deployed()

    // Get proofs
    this.uPrecomputesProof = await getSolidityCallProof('u-precomputes-exploit')
    this.ecdsaProof = await getSolidityCallProof('ecdsa-exploit')
  })

  it('should not pass with exploited inputs', async function () {
    // Choose a public key I want (e.g. vitalik)
    const vitalikPubkeyUncompressed =
      '04e95ba0b752d75197a8bad8d2e6ed4b9eb60a1e8b08d257927d0df4f3ea6860992aac5e614a83f1ebe4019300373591268da38871df019f694f8e3190e493e711'
    const vitalikAddress = computeAddress(`0x${vitalikPubkeyUncompressed}`)

    // Vitalik's address
    // https://etherscan.io/address/0xd8da6bf26964af9d7eed9e03e53415d37aa96045
    expect(vitalikAddress).to.equal(
      '0xd8dA6BF26964aF9D7eEd9e03E53415D37aA96045'
    )

    const publicKey = secp256k1.keyFromPublic(vitalikPubkeyUncompressed, 'hex')
    const pkPoint = publicKey.getPublic()

    // Find U and T for this public key.
    // let r = 1
    // let s = 1
    // let U = m * G
    // let T = Q_a - U
    //  => s * T + U = Q_a

    // Get m:
    const hashedMessageField = new BN(
      hashPersonalMessage(Buffer.from(getMessage()))
    ).mod(secp256k1.curve.n)

    // Find U = m * G
    const uPoint = secp256k1.curve.g.mul(hashedMessageField)

    // T = Q_a - U
    const negUPoint = uPoint.neg()
    const tPoint = pkPoint.add(negUPoint)

    // s = 1
    const s = new BN(1)
    const sRegisters = splitToRegisters(s)

    // r = 1 => r^{-1} = 1
    // -(r^{-1}) = n - 1 mod n
    // If I pass in this value as rInv into the UPrecomputesChecker proof,
    // I will get:
    //  -(r^{-1}) = 1
    // This makes the math easier to work with.
    // const rInvNegated = secp256k1.curve.n.sub(new BN(1))

    const T = [splitToRegisters(tPoint.x), splitToRegisters(tPoint.y)]
    const U = [splitToRegisters(uPoint.x), splitToRegisters(uPoint.y)]

    const TPrecomputes = getPointPrecomputes(tPoint)

    const witnessInput = {
      U,
      s: sRegisters,
      scalarForT: sRegisters,
      TPrecomputes,
      T,
    }
    await expectAssertFailure(() => this.circuit.calculateWitness(witnessInput))
    // const witness = await this.circuit.calculateWitness(witnessInput)

    // await this.circuit.assertOut(witness, {})

    // const uWitnessInput = {
    //   U,
    //   rInv: splitToRegisters(rInvNegated),
    // }
    // const uWitness = await this.uCircuit.calculateWitness(uWitnessInput)
    // await this.uCircuit.assertOut(uWitness, {})

    // const mimc7 = await new Mimc7().prepare()
    // const inputs = [...sRegisters, ...U[0], ...U[1], vitalikAddress]
    // const hash = mimc7.hash(inputs)
    // expect(hash).equal(witness[1])
    // expect(witness[2]).to.eq(uWitness[1])
  })

  it("cannot verify a proof of vitalik's nullifier without knowing private key", async function () {
    await expect(
      this.contract.verifyProofs(this.ecdsaProof, this.uPrecomputesProof)
    ).to.be.revertedWith('ECDSA proof failed')
  })
})
